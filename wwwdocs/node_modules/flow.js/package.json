{
  "name": "flow.js",
  "version": "0.2.6",
  "author": {
    "name": "it-ony",
    "email": "flow.js@it-ony.de"
  },
  "description": "a asynchronous-asynchronous flow control library which runs on node and in browsers",
  "scripts": {
    "test": "mocha -R spec"
  },
  "main": "./lib/flow",
  "repository": {
    "type": "git",
    "url": "https://github.com/it-ony/flow.js.git"
  },
  "keywords": [
    "flow-control",
    "flow",
    "control",
    "async",
    "asynchronous",
    "chain",
    "sync",
    "synchronous",
    "sequence",
    "parallel",
    "error"
  ],
  "devDependencies": {
    "chai": "*",
    "mocha": "*"
  },
  "license": "MIT",
  "engine": {
    "node": ">=0.4"
  },
  "readme": "[![build status](https://secure.travis-ci.org/it-ony/flow.js.png)](http://travis-ci.org/it-ony/flow.js)\n# flow.js\n## Introduction\n\nflow.js is a synchron-asynchron flow control library which runs on node and in browsers.\nThe functionallity of the library is inspired by node-seq (https://github.com/substack/node-seq) and async (https://github.com/caolan/async). The source is written from scratch.\n\n## Features\n\n* sequence flow (seq)\n* parallel flow (par) - executes functions in parallel\n* parallel flow for each (parEach) - execute one function in parallel for each item inside a given as array or object\n* seqEach - execute sequence for each function given as array\n* end  - breaks the flow from inside an action\n\n## Possible features (if somebody like or need)\n\n* catch     - adds a catch action, which will handle erros instead of exec action\n* autoexec  - automatically execute flow\n\n## Usage\n\n### Create a flow and execute\n\n```javascript\n\n    flow()\n       .exec(function (err, results) {\n            if (err) {\n                // some error inside the flow\n            } else {\n                // access to results\n            }\n       });\n```\n### Add a sequence\n\n#### execute synchron method in sequence\n\n```javascript\n    flow()\n       .seq(function(){\n           // do something synchron\n       })\n       .exec(function (err, results) {           \n       });\n\n```\n\n#### execute synchron method in sequence\n\n```javascript\n    flow()\n       .seq(function(cb){\n           // do something asynchron\n           setTimeout(function(){\n                // invoke callback\n                cb(null, \"result of this sequence\");\n           }, 1000);\n       })\n       .exec(function (err, results) {\n       });\n\n```\n\n\n#### sequence with variable registration\n\n```javascript\n    flow()\n       .seq(\"myVar\", function(){\n           return \"valueOfMyVar\";\n       })\n       .exec(function (err, results) {\n           console.log(results.myVar);\n       });\n\n```\n\n### Add parallel control flow\n\n#### asynchron and synchron control parallel control flows\n\n```javascript\n    flow()\n       .par([\n            function() {\n                // synchron method\n            },\n            function (cb) {\n                // asynchron method\n            }\n            // and even more\n       ])\n       .exec(function (err, results) {\n       });\n\n```\n\n#### asynchron and synchron control parallel with variable registration\n\n```javascript\n    flow()\n       .par({\n            a: function() {\n                // synchron method\n                return 123;\n            },\n            b: function (cb) {\n                // asynchron method\n                setTimeout(function(){\n                    cb(null, \"I completed after 100ms\");\n                }, 100);\n            }\n            // and even more\n       })\n       .exec(function (err, results) {\n            console.log(results);\n            // results.a = 123;\n            // results.b = \"I completed after 100ms\");\n       });\n\n```\n\n#### synchron control parallel each without variable registration\n\n```javascript\n    flow()\n        .parEach([1, 2, 3], function(value) {\n            console.log(value);\n        })\n        .exec(function (err, results) {\n            /*\n                output in console could be\n                    1      2      3\n                    2  or  1  or  2  or ...\n                    3      3      1\n            */\n        })\n\n```\n\n#### synchron control parallel each with variable registration\n\n```javascript\n    flow()\n        .parEach({\n            a: 1,\n            b: 2,\n            c: 3\n        }, function(value) {\n            return value*3;\n        })\n        .exec(function (err, results) {\n            console.log(results);   // [3, 6, 9]\n        })\n\n```\n\n#### asynchron control parallel each with and without variable registration\n\n```javascript\n    flow()\n        .parEach([\"do\", \"it\"], function(value, cb) {\n            setTimeout(function(){\n                console.log(value); // synchron\n            }, 10);\n        })\n        .parEach({\n            a: 1,\n            b: 2\n        }, function(value, cb) {\n                    setTimeout(function(){\n                        cb(null, value*2);// doubles the value and saves it to a or b\n                    }, 10);\n                })\n        .exec(function (err, results) {\n            console.log(results);   // {a: 2, b: 4}\n        })\n\n```\n\n\n### end flow from inside an synchron action\n\n```javascript\n    flow()\n        .seq(\"a\", function() {\n            // do something\n        }\n        .par({\n            b: function() {\n                // do something synchron in parallel ...\n\n                // end flow on condition\n                if (condition) {\n                    this.end(); // end flow after return statement\n                    return -2;\n                }\n\n                return 2;\n            },\n            c: function(cb) {\n                // ... with something asynchron\n\n                // end flow the asynchron way\n                this.end(null, 3); // or cb.end(null, 3) or cb(null, 3, true) or this(null, 3, true)\n            }\n        })\n        .seq(\"e\", function() {\n            // this would executed, because either b or c will end the flow\n        }\n        .exec(function(err, results) {\n            /* this function is called on\n               * error thrown in synchron method\n               * error object passed in asynchron method\n               * this.end() is called\n               * flow is executed completely\n            */\n        });\n```\n\n## Changelog\n\n### 0.2.3\n\n* added global error handler, which get called if an error occurs in exec block\n",
  "readmeFilename": "README.md",
  "_id": "flow.js@0.2.6",
  "dist": {
    "shasum": "5de86aaab650ad50d901e6d197d8a3e31cd25085",
    "tarball": "http://registry.npmjs.org/flow.js/-/flow.js-0.2.6.tgz"
  },
  "_npmVersion": "1.1.65",
  "_npmUser": {
    "name": "it-ony",
    "email": "npm@it-ony.de"
  },
  "maintainers": [
    {
      "name": "it-ony",
      "email": "npm@it-ony.de"
    }
  ],
  "directories": {},
  "_shasum": "5de86aaab650ad50d901e6d197d8a3e31cd25085",
  "_from": "flow.js@",
  "_resolved": "https://registry.npmjs.org/flow.js/-/flow.js-0.2.6.tgz"
}
